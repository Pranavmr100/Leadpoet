# neurons/server.py
import bittensor as bt
from flask import Flask, request, jsonify
import json
import os
import config  

app = Flask(__name__)

# Initialize Bittensor subnet components
subtensor = bt.subtensor(network="finney")  # Connect to Bittensor testnet
wallet = bt.wallet()  # Your TAO wallet (configure with your hotkey/coldkey)
dendrite = bt.dendrite(wallet=wallet)  # For sending requests to miners/validators

# Placeholder for miner and validator UIDs (in a real subnet, discover dynamically)
MINER_UID = 1  # Replace with actual miner UID
VALIDATOR_UID = 2  # Replace with actual validator UID

@app.route('/submit_leads', methods=['POST'])
def submit_leads():
    data = request.get_json()
    if not data or "leads" not in data:
        return jsonify({"status": "error", "message": "Invalid lead data"}), 400
    # In a real subnet, this would forward leads to validators
    return jsonify({"status": "success", "message": f"Received leads: {data}"}), 200

@app.route('/leads', methods=['GET'])
def get_leads():
    industry = request.args.get('industry', 'N/A')
    location = request.args.get('location', 'N/A')
    limit = request.args.get('limit', '50')

    print(f"Received client request: industry={industry}, location={location}, limit={limit}")

    try:
        # Step 1: Send request to miners
        miner_request = {
            "industry": industry,
            "location": location,
            "limit": int(limit)
        }
        miner_response = dendrite.call(
            target=MINER_UID,
            method="generate_leads",
            request_data=miner_request,
            timeout=60
        )

        if not miner_response or "leads" not in miner_response:
            return jsonify({"status": "error", "message": "No leads generated by miners"}), 500

        leads = miner_response["leads"]

        # Step 2: Send leads to validators
        validator_request = {
            "leads": leads,
            "industry": industry
        }
        validator_response = dendrite.call(
            target=VALIDATOR_UID,
            method="validate_leads",
            request_data=validator_request,
            timeout=60
        )

        if not validator_response or "validated_leads" not in validator_response:
            return jsonify({"status": "error", "message": "Validation failed"}), 500

        validated_leads = validator_response["validated_leads"]

        # Step 3: Return the validated leads to the client
        return jsonify({
            "status": "success",
            "message": f"Generated and validated {limit} leads for {industry} from {location}.",
            "industry": industry,
            "location": location,
            "limit": limit,
            "leads": validated_leads
        }), 200

    except Exception as e:
        return jsonify({"status": "error", "message": f"Error: {str(e)}"}), 500

@app.route('/validation_status', methods=['GET'])
def validation_status():
    submission_id = request.args.get('submission_id')
    if not submission_id:
        return jsonify({"status": "error", "message": "submission_id required"}), 400
    # Placeholder for now - would query subnet for validation status
    return jsonify({"status": "success", "submission_id": submission_id, "message": "Validation in progress"}), 200

if __name__ == '__main__':
    app.run(host=config.API_HOST, port=config.API_PORT)